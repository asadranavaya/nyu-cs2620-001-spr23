/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package floyd.warshall;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Vector;

public class App {
    static final int MAXN = 100;

    public static final ArrayList<constants.node_order> ALL_NODES = new ArrayList<>();
    // Infinite value for array
    static int INF = (int) 1e7;

    static double[][] dis = new double[MAXN][MAXN];
    static int[][] next = new int[MAXN][MAXN];

    // Initializing the distance and
    // Next array
    static void initialise(int V, double[][] graph) {
        for (int i = 0; i < V; i++) {
            for (int j = 0; j < V; j++) {
                dis[i][j] = graph[i][j];

                // No edge between node
                // i and j
                if (graph[i][j] == INF)
                    next[i][j] = -1;
                else
                    next[i][j] = j;
            }
        }
    }

    // Function construct the shortest
    // path between u and v
    static Vector<Integer> constructPath(int u,
            int v) {

        // If there's no path between
        // node u and v, simply return
        // an empty array
        if (next[u][v] == -1)
            return null;

        // Storing the path in a vector
        Vector<Integer> path = new Vector<Integer>();
        path.add(u);

        while (u != v) {
            u = next[u][v];
            path.add(u);
        }
        return path;
    }

    // Standard Floyd Warshall Algorithm
    // with little modification Now if we find
    // that dis[i][j] > dis[i][k] + dis[k][j]
    // then we modify next[i][j] = next[i][k]
    static void floydWarshall(int V) {
        for (int k = 0; k < V; k++) {
            for (int i = 0; i < V; i++) {
                for (int j = 0; j < V; j++) {

                    // We cannot travel through
                    // edge that doesn't exist
                    if (dis[i][k] == INF ||
                            dis[k][j] == INF)
                        continue;

                    if (dis[i][j] > dis[i][k] +
                            dis[k][j]) {
                        dis[i][j] = dis[i][k] +
                                dis[k][j];
                        next[i][j] = next[i][k];
                    }
                }
            }
        }
    }

    // Print the shortest path
    static String printPath(Vector<Integer> path, double[][] originalGraph) {
        final StringBuilder output = new StringBuilder();
        int n = path.size();
        double originalLatency = originalGraph[path.get(0)][path.get(n - 1)];
        double finalLatency = dis[path.get(0)][path.get(n - 1)];

        if (optimizedPathAvgLatencyMap.get(path) != null) {
            optimizedPathAvgLatencyMap.put(path, optimizedPathAvgLatencyMap.get(path) + finalLatency);
        } else {
            optimizedPathAvgLatencyMap.put(path, finalLatency);
        }

        if (optimizedPathAvgOriginalLatencyMap.get(path) != null) {
            optimizedPathAvgOriginalLatencyMap.put(path,
                    optimizedPathAvgOriginalLatencyMap.get(path) + originalLatency);
        } else {
            optimizedPathAvgOriginalLatencyMap.put(path, originalLatency);
        }

        for (int i = 0; i < n - 1; i++) {
            // finalLatency += dis[path.get(i)][path.get(i + 1)];
            output.append(ALL_NODES.get((path.get(i))) + " -> ");
        }
        double percentOptimized = 100 * (1 - finalLatency / originalLatency);
        output.append(
                ALL_NODES.get(path.get(n - 1)) + " | Original Latency: " + originalLatency + ", optimized latency: "
                        + finalLatency + ", Percent Optimized: " + percentOptimized + "\n");
        return output.toString();
    }

    static String printPath(Vector<Integer> path) {
        final StringBuilder output = new StringBuilder();
        int n = path.size();
        for (int i = 0; i < n - 1; i++) {
            output.append(ALL_NODES.get((path.get(i))) + " -> ");
        }
        output.append(
                ALL_NODES.get(path.get(n - 1)) + "\n");
        return output.toString();
    }

    public static final HashMap<Vector<Integer>, Double> optimizedPathAvgLatencyMap = new HashMap<>();
    public static final HashMap<Vector<Integer>, Double> optimizedPathAvgOriginalLatencyMap = new HashMap<>();

    // Driver code
    public static void main(String[] args) throws IOException {
        final HashMap<Vector<Integer>, Integer> optimizedPathCountMap = new HashMap<>();
        final HashMap<Integer, Integer> pathHopCountMap = new HashMap<>();
        for (final constants.node_order m : constants.node_order.values()) {
            ALL_NODES.add(m);
        }
        int V = constants.NUM_NODES;

        // Output one file, with arbitrage opportunity
        final FileWriter fWriter = new FileWriter("output.txt");
        final BufferedWriter bWriter = new BufferedWriter(fWriter);

        int paths_already_optimized = 0;

        // Read directory and store list of file names
        final List<File> files = new ArrayList(Arrays.asList(new File(constants.INPUT_STRING).listFiles()));
        for (final File file : files) {
            // Open each file
            final FileReader fileReader = new FileReader(file);
            try (// create a shared buffered reader for each distance matrix within file
                    BufferedReader currentOpenDocument = new BufferedReader(fileReader)) {
                while (true) {
                    final double[][] graph = helpers.readGraphFromOpenDocument(currentOpenDocument);
                    if (graph == null)
                        break;
                    // output arbitrage opportunities
                    // Function to initialise the
                    // distance and Next array
                    initialise(V, graph);

                    // Calling Floyd Warshall Algorithm,
                    // this will update the shortest
                    // distance as well as Next array
                    floydWarshall(V);
                    Vector<Integer> path;
                    int time_exec = 0;
                    // Construct path for every node pair
                    for (int j = 0; j < constants.NUM_NODES; ++j) {
                        for (int k = 0; k < constants.NUM_NODES; ++k) {
                            path = constructPath(j, k);
                            if (path.size() > 2) {
                                // line.append(printPath(path, graph));
                                // bWriter.write(printPath(path, graph));
                                printPath(path, graph);
                                if (optimizedPathCountMap.get(path) != null) {
                                    optimizedPathCountMap.put(path, optimizedPathCountMap.get(path) + 1);
                                } else {
                                    optimizedPathCountMap.put(path, 1);
                                }

                                if (pathHopCountMap.get(path.size()) != null) {
                                    pathHopCountMap.put(path.size(), pathHopCountMap.get(path.size()) + 1);
                                } else {
                                    pathHopCountMap.put(path.size(), 1);
                                }
                                time_exec++;
                            } else {
                                ++paths_already_optimized;
                            }
                        }
                    }
                    // bWriter.write("--------------------------------MATRIX--------------------------------\n");
                    // System.out.println(time_exec);
                }
            }

        }
        //// initialize
        // for (int i = 0; i < constants.NUM_TRIALS; ++i) {
        // final double[][] graph = helpers.readDocument(constants.INPUT_STRING + i);
        // // output arbitrage opportunities
        // // Function to initialise the
        // // distance and Next array
        // initialise(V, graph);
        //
        // // Calling Floyd Warshall Algorithm,
        // // this will update the shortest
        // // distance as well as Next array
        // floydWarshall(V);
        // Vector<Integer> path;
        // int time_exec = 0;
        // // Construct path for every node pair
        // for (int j = 0; j < constants.NUM_NODES; ++j) {
        // for (int k = 0; k < constants.NUM_NODES; ++k) {
        // path = constructPath(j, k);
        // if (path.size() > 2) {
        // // line.append(printPath(path, graph));
        // bWriter.write(printPath(path, graph));
        // if (optimizedPathCountMap.get(path) != null) {
        // optimizedPathCountMap.put(path, optimizedPathCountMap.get(path) + 1);
        // } else {
        // optimizedPathCountMap.put(path, 1);
        // }
        //
        // if (pathHopCountMap.get(path.size()) != null) {
        // pathHopCountMap.put(path.size(), pathHopCountMap.get(path.size()) + 1);
        // } else {
        // pathHopCountMap.put(path.size(), 1);
        // }
        // time_exec++;
        // } else {
        // ++paths_already_optimized;
        // }
        // }
        // }
        // bWriter.write("--------------------------------MATRIX_" + i +
        // "--------------------------------\n");
        // // System.out.println(time_exec);
        // }

        final StringBuilder line = new StringBuilder();
        // bWriter.append("Paths already optimized: " + paths_already_optimized + "\n");
        // for (final Map.Entry<Integer, Integer> entry : pathHopCountMap.entrySet()) {
        // bWriter.append(
        // "Additional Hops: " + (entry.getKey() - 2) + " Number of paths: " +
        // entry.getValue() + "\n");
        // }
        final HashMap<Vector<Integer>, Integer> sortedOptimizedPathMap = helpers.sortByValue(optimizedPathCountMap);
        bWriter.append("path,times_optimized,avg_percent_optimized,avg_optimized_latency_ms,number_hops\n");
        for (final Map.Entry<Vector<Integer>, Integer> entry : sortedOptimizedPathMap.entrySet()) {
            final double avgLatency = optimizedPathAvgLatencyMap.get(entry.getKey()) / entry.getValue();
            final double avgOriginalLatency = optimizedPathAvgOriginalLatencyMap.get(entry.getKey()) / entry.getValue();
            final double avgPercentOptimized = 100 * (1 - avgLatency / avgOriginalLatency);
            final double avgOptimizedLatency = 100 * (avgOriginalLatency - avgLatency);
            bWriter.append(
                    printPath(entry.getKey()).substring(0, printPath(entry.getKey()).length() - 1) + ","
                            + entry.getValue() + ","
                            + avgPercentOptimized + "," + avgOptimizedLatency + "," + (entry.getKey().size() - 2)
                            + "\n");
        }
        bWriter.close();
    }
}
